<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Industrial Laser Cut System for Glasses &amp; Transparent Materials</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/lucide/0.263.1/lucide.min.css" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  html, body, #root { min-height: 100vh; width: 100%; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #030308; color: #fff; }

  .app-wrap { min-height: 100vh; background: linear-gradient(135deg, #030312, #0c0a2a, #030312); padding: 16px; }
  .max-container { max-width: 1900px; margin: 0 auto; }
  .text-center { text-align: center; }
  .mb-4 { margin-bottom: 16px; }
  .mb-2 { margin-bottom: 8px; }
  .mb-3 { margin-bottom: 12px; }
  .mt-2 { margin-top: 8px; }
  .mt-3 { margin-top: 12px; }
  .mt-4 { margin-top: 16px; }
  .pt-1 { padding-top: 4px; }

  h1 { font-size: 1.75rem; font-weight: 700; color: #fff; margin-bottom: 8px; }
  @media (max-width: 768px) { h1 { font-size: 1.2rem; } }

  .grid-main { display: grid; grid-template-columns: 3fr 2fr; gap: 16px; }
  @media (max-width: 1024px) { .grid-main { grid-template-columns: 1fr; } }

  .panel { background: #111827; border-radius: 8px; padding: 12px; }
  .panel-canvas { grid-column: 1; }

  .panel-title { font-size: 14px; font-weight: 700; color: #fff; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
  .panel-title svg { width: 16px; height: 16px; }

  .controls-col { display: flex; flex-direction: column; gap: 12px; max-height: 780px; overflow-y: auto; }
  @media (max-width: 1024px) { .controls-col { max-height: none; } }

  .flex-between { display: flex; justify-content: space-between; align-items: center; }
  .flex-gap-2 { display: flex; gap: 8px; align-items: center; }

  .btn { padding: 4px 12px; border-radius: 4px; font-size: 13px; border: none; cursor: pointer; color: #fff; display: inline-flex; align-items: center; gap: 4px; }
  .btn-green { background: #16a34a; }
  .btn-green:hover { background: #15803d; }
  .btn-green:disabled { background: #4b5563; cursor: not-allowed; }
  .btn-red { background: #dc2626; }
  .btn-red:hover { background: #b91c1c; }
  .btn-purple { background: #7c3aed; }
  .btn-gray { background: #374151; }

  canvas { width: 100%; border: 2px solid #3b82f6; border-radius: 8px; cursor: move; background: #000; display: block; }

  .progress-bar-outer { width: 100%; background: #374151; border-radius: 9999px; height: 24px; overflow: hidden; }
  .progress-bar-inner { height: 24px; border-radius: 9999px; transition: width 0.3s; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 700; color: #fff; min-width: 40px; }
  .progress-blue { background: linear-gradient(90deg, #3b82f6, #a855f7); }
  .progress-green { background: linear-gradient(90deg, #22c55e, #10b981); }

  select, input[type="number"] { width: 100%; background: #1f2937; color: #fff; padding: 6px 8px; border-radius: 4px; border: 1px solid #4b5563; font-size: 12px; }
  select:disabled, input:disabled { opacity: 0.5; }

  input[type="range"] { width: 100%; accent-color: #3b82f6; }
  input[type="checkbox"] { width: 16px; height: 16px; }

  label { display: block; color: #d1d5db; font-size: 12px; margin-bottom: 4px; }
  .label-bold { font-weight: 700; }
  .label-yellow { color: #facc15; }
  .label-cyan { color: #22d3ee; }

  .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }

  .info-box { background: rgba(30, 58, 138, 0.3); padding: 8px; border-radius: 4px; font-size: 12px; }
  .info-box .title { color: #bfdbfe; }
  .info-box .val { color: #fff; }

  .yellow-box { background: rgba(113, 63, 18, 0.3); padding: 8px; border-radius: 4px; border: 1px solid #eab308; }
  .yellow-box label { color: #fde68a; font-weight: 700; }
  .yellow-box .hint { font-size: 11px; color: #fde68a; margin-top: 4px; }

  .material-panel { background: linear-gradient(135deg, #1e3a8a, #312e81); border-radius: 8px; padding: 12px; }
  .material-panel h3 { font-size: 14px; font-weight: 700; color: #fff; margin-bottom: 8px; }
  .material-props { font-size: 12px; color: #dbeafe; display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
  .material-desc { font-size: 12px; color: #bfdbfe; font-style: italic; margin-top: 8px; }

  .border-yellow { border: 2px solid #eab308; }
  .border-yellow select { border-color: #eab308; }
  .border-cyan select { border-color: #22d3ee; }
  .border-yellow-input { border-color: #eab308 !important; text-align: center; font-weight: 700; }

  .footer-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-top: 16px; }
  @media (max-width: 768px) { .footer-grid { grid-template-columns: 1fr 1fr; } }
  @media (max-width: 480px) { .footer-grid { grid-template-columns: 1fr; } }
  .footer-card { background: #111827; border-radius: 8px; padding: 12px; }
  .footer-card h4 { font-weight: 700; font-size: 13px; margin-bottom: 4px; }
  .footer-card p { color: #d1d5db; font-size: 12px; line-height: 1.5; }
  .c-orange { color: #fb923c; }
  .c-green { color: #4ade80; }
  .c-blue { color: #60a5fa; }
  .c-purple { color: #c084fc; }

  .space-y-2 > * + * { margin-top: 8px; }
  .space-y-3 > * + * { margin-top: 12px; }

  .italic { font-style: italic; }
  .text-xs { font-size: 12px; }
  .text-gray-400 { color: #9ca3af; }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;

// Simple SVG icons to replace lucide-react
const PlayIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>;
const PauseIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>;
const RotateIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>;
const SettingsIcon = ({color}) => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke={color||"currentColor"} strokeWidth="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>;

function IndustrialLaserCutthrough() {
  const materialsDatabase = {
    'fused_silica': {
      name: 'Fused Silica (SiO\u2082)',
      density: 2.203, transmissionAt1030nm: 0.92, transmissionAt515nm: 0.91, transmissionAt355nm: 0.85,
      ablationThreshold1030nm: 3.0, ablationThreshold515nm: 2.5, ablationThreshold355nm: 2.0,
      thermalConductivity: 1.38, specificHeat: 0.74, thermalExpansion: 5.5e-7,
      refractiveIndex1030nm: 1.45, refractiveIndex515nm: 1.46,
      meltingPoint: 1713, youngsModulus: 73, hardness: 5.5,
      color: { r: 230, g: 235, b: 245, a: 0.15 },
      description: 'High purity synthetic silica - excellent for UV/IR optics'
    },
    'sapphire': {
      name: 'Sapphire (Al\u2082O\u2083)',
      density: 3.98, transmissionAt1030nm: 0.85, transmissionAt515nm: 0.87, transmissionAt355nm: 0.82,
      ablationThreshold1030nm: 4.5, ablationThreshold515nm: 3.5, ablationThreshold355nm: 2.8,
      thermalConductivity: 35, specificHeat: 0.76, thermalExpansion: 5.8e-6,
      refractiveIndex1030nm: 1.76, refractiveIndex515nm: 1.77,
      meltingPoint: 2040, youngsModulus: 345, hardness: 9.0,
      color: { r: 240, g: 245, b: 255, a: 0.12 },
      description: 'Crystalline alumina - extreme hardness, good thermal conductor'
    },
    'bk7': {
      name: 'Borosilicate Glass (BK7)',
      density: 2.51, transmissionAt1030nm: 0.90, transmissionAt515nm: 0.92, transmissionAt355nm: 0.88,
      ablationThreshold1030nm: 2.5, ablationThreshold515nm: 2.0, ablationThreshold355nm: 1.8,
      thermalConductivity: 1.11, specificHeat: 0.83, thermalExpansion: 7.1e-6,
      refractiveIndex1030nm: 1.507, refractiveIndex515nm: 1.519,
      meltingPoint: 557, youngsModulus: 82, hardness: 6.0,
      color: { r: 235, g: 240, b: 235, a: 0.18 },
      description: 'Common optical glass - easier to process than fused silica'
    },
    'soda_lime': {
      name: 'Soda-Lime Glass',
      density: 2.52, transmissionAt1030nm: 0.88, transmissionAt515nm: 0.90, transmissionAt355nm: 0.84,
      ablationThreshold1030nm: 2.0, ablationThreshold515nm: 1.6, ablationThreshold355nm: 1.4,
      thermalConductivity: 1.05, specificHeat: 0.84, thermalExpansion: 9.0e-6,
      refractiveIndex1030nm: 1.51, refractiveIndex515nm: 1.52,
      meltingPoint: 730, youngsModulus: 69, hardness: 5.5,
      color: { r: 240, g: 250, b: 240, a: 0.20 },
      description: 'Standard window glass - easiest to ablate'
    },
    'silicon': {
      name: 'Silicon (Si)',
      density: 2.33, transmissionAt1030nm: 0.55, transmissionAt515nm: 0.01, transmissionAt355nm: 0.001,
      ablationThreshold1030nm: 0.5, ablationThreshold515nm: 0.3, ablationThreshold355nm: 0.2,
      thermalConductivity: 148, specificHeat: 0.71, thermalExpansion: 2.6e-6,
      refractiveIndex1030nm: 3.48, refractiveIndex515nm: 4.24,
      meltingPoint: 1414, youngsModulus: 130, hardness: 7.0,
      color: { r: 80, g: 80, b: 85, a: 0.8 },
      description: 'Semiconductor wafer - absorbs visible/UV, transparent IR'
    },
    'pmma': {
      name: 'PMMA (Acrylic)',
      density: 1.18, transmissionAt1030nm: 0.92, transmissionAt515nm: 0.93, transmissionAt355nm: 0.001,
      ablationThreshold1030nm: 0.8, ablationThreshold515nm: 0.6, ablationThreshold355nm: 0.1,
      thermalConductivity: 0.19, specificHeat: 1.42, thermalExpansion: 7.0e-5,
      refractiveIndex1030nm: 1.49, refractiveIndex515nm: 1.492,
      meltingPoint: 130, youngsModulus: 3.3, hardness: 3.0,
      color: { r: 250, g: 250, b: 250, a: 0.10 },
      description: 'Transparent plastic - use UV laser for clean cuts'
    }
  };

  const [selectedMaterial, setSelectedMaterial] = useState('fused_silica');
  const currentMaterial = materialsDatabase[selectedMaterial];

  const [sampleWidth, setSampleWidth] = useState(50);
  const [sampleLength, setSampleLength] = useState(50);
  const [sampleThickness, setSampleThickness] = useState(10);

  const laserSystems = {
    femtosecond: {
      'Coherent Monaco': { pulseWidth: [250, 400], power: [0, 40], repRate: [200, 1000], wavelengths: [1030] },
      'Trumpf TruMicro 5000': { pulseWidth: [400, 800], power: [0, 50], repRate: [200, 800], wavelengths: [1030, 515] },
      'Amplitude Satsuma': { pulseWidth: [250, 500], power: [0, 60], repRate: [1, 2000], wavelengths: [1030, 515, 343] },
      'Light Conversion Pharos': { pulseWidth: [170, 10000], power: [0, 20], repRate: [1, 1000], wavelengths: [1030, 515, 343] },
      'Spectra-Physics Spirit': { pulseWidth: [340, 680], power: [0, 30], repRate: [1, 1000], wavelengths: [1030, 515] },
      'EKSPLA Atlantic': { pulseWidth: [190, 600], power: [0, 40], repRate: [1, 1000], wavelengths: [1030, 515, 343] }
    },
    picosecond: {
      'Trumpf TruMicro 2000': { pulseWidth: [6000, 12000], power: [0, 30], repRate: [200, 800], wavelengths: [1064, 532] },
      'IPG GLPN': { pulseWidth: [10000, 15000], power: [0, 50], repRate: [200, 500], wavelengths: [1064, 532, 355] },
      'Coherent Talisker': { pulseWidth: [10000, 20000], power: [0, 100], repRate: [100, 2000], wavelengths: [1064, 532] }
    },
    nanosecond: {
      'IPG YLPN': { pulseWidth: [100000, 500000], power: [0, 100], repRate: [20, 500], wavelengths: [1064, 532] },
      'Coherent Avia': { pulseWidth: [25000, 250000], power: [0, 15], repRate: [1, 150], wavelengths: [355, 266] }
    }
  };

  const [laserType, setLaserType] = useState('femtosecond');
  const [laserModel, setLaserModel] = useState('Amplitude Satsuma');
  const [wavelength, setWavelength] = useState(1030);
  const [pulseWidth, setPulseWidth] = useState(300);
  const [averagePower, setAveragePower] = useState(20);
  const [repetitionRate, setRepetitionRate] = useState(200);
  const [peakPower, setPeakPower] = useState(0);
  const [energyPerPulse, setEnergyPerPulse] = useState(0);
  const [burstMode, setBurstMode] = useState(true);
  const [pulsesPerBurst, setPulsesPerBurst] = useState(5);
  const [burstFrequency, setBurstFrequency] = useState(65);
  const [beamType, setBeamType] = useState('bessel');
  const [focalLength, setFocalLength] = useState(100);
  const [numericalAperture, setNumericalAperture] = useState(0.25);
  const [beamQuality, setBeamQuality] = useState(1.2);
  const [beamDiameter, setBeamDiameter] = useState(8);
  const [spotSize, setSpotSize] = useState(0);
  const [rayleighRange, setRayleighRange] = useState(0);
  const [scanningSystem, setScanningSystem] = useState('galvo');
  const [scanSpeed, setScanSpeed] = useState(1000);
  const [cutMode, setCutMode] = useState('hole');
  const [holeDiameter, setHoleDiameter] = useState(10);
  const [lineLength, setLineLength] = useState(20);
  const [lineWidth, setLineWidth] = useState(0.5);
  const [cutDepth, setCutDepth] = useState(5);
  const [drillingStrategy, setDrillingStrategy] = useState('helical');
  const [numberOfPasses, setNumberOfPasses] = useState(200);
  const [pulseOverlap, setPulseOverlap] = useState(85);
  const [hatchSpacing, setHatchSpacing] = useState(10);
  const [zOffset, setZOffset] = useState(0);
  const [assistGas, setAssistGas] = useState('argon');
  const [gasPressure, setGasPressure] = useState(3);
  const [gasFlowRate, setGasFlowRate] = useState(15);
  const [gasAngle, setGasAngle] = useState(30);
  const [isRunning, setIsRunning] = useState(false);
  const [currentDepth, setCurrentDepth] = useState(0);
  const [currentPass, setCurrentPass] = useState(0);
  const [processingTime, setProcessingTime] = useState(0);
  const [estimatedTime, setEstimatedTime] = useState(0);
  const [materialRemoved, setMaterialRemoved] = useState(0);
  const [isComplete, setIsComplete] = useState(false);
  const [cameraRotX, setCameraRotX] = useState(-25);
  const [cameraRotY, setCameraRotY] = useState(45);
  const [cameraZoom, setCameraZoom] = useState(600);
  const [showPlasma, setShowPlasma] = useState(false);
  const [rotationAngle, setRotationAngle] = useState(0);
  const [autoRotate, setAutoRotate] = useState(false);

  const canvasRef = useRef(null);
  const isDragging = useRef(false);
  const lastMouse = useRef({ x: 0, y: 0 });

  useEffect(() => {
    const energy = (averagePower * 1e6) / (repetitionRate * 1000);
    setEnergyPerPulse(energy);
    const lambda = wavelength / 1000;
    const spot = (4 * lambda * focalLength * beamQuality) / (Math.PI * beamDiameter * 1000);
    setSpotSize(spot);
    const rayleigh = (Math.PI * Math.pow(spot / 2, 2)) / lambda;
    setRayleighRange(rayleigh);
    if (laserType === 'femtosecond') {
      const peak = energy / (pulseWidth / 1000);
      setPeakPower(peak);
    }
    const circumference = Math.PI * holeDiameter;
    const pulsesPerRevolution = Math.ceil(circumference * 1000 / spot * (100 / (100 - pulseOverlap)));
    const totalPulses = pulsesPerRevolution * numberOfPasses;
    const timeSeconds = totalPulses / (repetitionRate * 1000);
    setEstimatedTime(timeSeconds);
  }, [wavelength, pulseWidth, averagePower, repetitionRate, focalLength, beamQuality, beamDiameter, holeDiameter, numberOfPasses, pulseOverlap, laserType]);

  const getCurrentModelSpecs = () => {
    return laserSystems[laserType][laserModel] || laserSystems[laserType][Object.keys(laserSystems[laserType])[0]];
  };

  const getAblationThreshold = () => {
    if (wavelength === 1030 || wavelength === 1064) return currentMaterial.ablationThreshold1030nm;
    if (wavelength === 515 || wavelength === 532) return currentMaterial.ablationThreshold515nm;
    if (wavelength === 355 || wavelength === 343) return currentMaterial.ablationThreshold355nm;
    return currentMaterial.ablationThreshold1030nm;
  };

  const spotArea = Math.PI * Math.pow(spotSize / 2, 2) / 1e8;
  const fluence = energyPerPulse / spotArea;
  const ablationThreshold = getAblationThreshold();
  const isAboveThreshold = fluence > ablationThreshold;
  const ablationDepthPerPulse = isAboveThreshold ? Math.pow(fluence / ablationThreshold, 0.7) * 0.12 : 0;
  const depthPerPass = (cutDepth * 1000) / numberOfPasses;

  const handleMouseDown = (e) => { isDragging.current = true; lastMouse.current = { x: e.clientX, y: e.clientY }; };
  const handleMouseMove = (e) => {
    if (!isDragging.current) return;
    const dx = e.clientX - lastMouse.current.x;
    const dy = e.clientY - lastMouse.current.y;
    setCameraRotY(prev => prev + dx * 0.3);
    setCameraRotX(prev => Math.max(-89, Math.min(89, prev + dy * 0.3)));
    lastMouse.current = { x: e.clientX, y: e.clientY };
  };
  const handleMouseUp = () => { isDragging.current = false; };

  // Touch support
  const handleTouchStart = (e) => {
    if (e.touches.length === 1) {
      isDragging.current = true;
      lastMouse.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
  };
  const handleTouchMove = (e) => {
    if (!isDragging.current || e.touches.length !== 1) return;
    e.preventDefault();
    const dx = e.touches[0].clientX - lastMouse.current.x;
    const dy = e.touches[0].clientY - lastMouse.current.y;
    setCameraRotY(prev => prev + dx * 0.3);
    setCameraRotX(prev => Math.max(-89, Math.min(89, prev + dy * 0.3)));
    lastMouse.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  };
  const handleTouchEnd = () => { isDragging.current = false; };

  const reset = () => {
    setIsRunning(false); setCurrentDepth(0); setCurrentPass(0);
    setProcessingTime(0); setRotationAngle(0); setMaterialRemoved(0); setIsComplete(false);
  };

  useEffect(() => {
    if (!isRunning || currentDepth >= cutDepth) {
      if (currentDepth >= cutDepth) { setIsRunning(false); setIsComplete(true); }
      return;
    }
    const interval = setInterval(() => {
      setRotationAngle(prev => (prev + 6) % 360);
      setProcessingTime(prev => prev + 0.05);
      setCurrentPass(prev => {
        const next = prev + 1;
        if (next <= numberOfPasses) {
          setCurrentDepth(d => Math.min(d + depthPerPass / 1000, cutDepth));
          if (cutMode === 'hole') {
            const volumePerPass = Math.PI * Math.pow(holeDiameter / 2, 2) * depthPerPass / 1000;
            setMaterialRemoved(m => m + volumePerPass);
          } else {
            const volumePerPass = lineLength * lineWidth * depthPerPass / 1000;
            setMaterialRemoved(m => m + volumePerPass);
          }
        }
        return next;
      });
      setShowPlasma(Math.random() > 0.3);
    }, 50);
    return () => clearInterval(interval);
  }, [isRunning, currentDepth, cutDepth, depthPerPass, numberOfPasses, holeDiameter, cutMode, lineLength, lineWidth]);

  useEffect(() => {
    if (!autoRotate) return;
    const interval = setInterval(() => { setCameraRotY(prev => (prev + 0.5) % 360); }, 50);
    return () => clearInterval(interval);
  }, [autoRotate]);

  // 3D Rendering
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    ctx.fillStyle = '#05050a';
    ctx.fillRect(0, 0, width, height);

    const project = (x, y, z) => {
      const angleY = (cameraRotY * Math.PI) / 180;
      const cosY = Math.cos(angleY), sinY = Math.sin(angleY);
      const x1 = x * cosY - z * sinY, z1 = x * sinY + z * cosY;
      const angleX = (cameraRotX * Math.PI) / 180;
      const cosX = Math.cos(angleX), sinX = Math.sin(angleX);
      const y1 = y * cosX - z1 * sinX, z2 = y * sinX + z1 * cosX;
      const perspective = cameraZoom;
      const scale = perspective / (perspective + z2);
      return { x: width / 2 + x1 * scale, y: height / 2 - y1 * scale, z: z2, scale };
    };

    const scale3D = 10;
    const w = sampleWidth * scale3D, l = sampleLength * scale3D, h = sampleThickness * scale3D;

    const vertices = [
      [-w/2,-h/2,-l/2],[w/2,-h/2,-l/2],[w/2,h/2,-l/2],[-w/2,h/2,-l/2],
      [-w/2,-h/2,l/2],[w/2,-h/2,l/2],[w/2,h/2,l/2],[-w/2,h/2,l/2],
    ];
    const projected = vertices.map(v => project(v[0], v[1], v[2]));
    const matColor = currentMaterial.color;
    const baseAlpha = matColor.a;

    const faces = [
      { indices: [4,5,6,7], color: `rgba(${matColor.r},${matColor.g},${matColor.b},${baseAlpha*0.67})` },
      { indices: [0,1,5,4], color: `rgba(${matColor.r},${matColor.g},${matColor.b},${baseAlpha})` },
      { indices: [1,2,6,5], color: `rgba(${matColor.r},${matColor.g},${matColor.b},${baseAlpha*1.33})` },
      { indices: [0,3,7,4], color: `rgba(${matColor.r},${matColor.g},${matColor.b},${baseAlpha*1.33})` },
      { indices: [3,2,6,7], color: `rgba(${matColor.r},${matColor.g},${matColor.b},${baseAlpha*1.67})` },
      { indices: [0,1,2,3], color: `rgba(${matColor.r},${matColor.g},${matColor.b},${baseAlpha*2.0})` },
    ];

    const facesWithZ = faces.map(face => ({
      ...face, avgZ: face.indices.reduce((sum, i) => sum + projected[i].z, 0) / face.indices.length
    }));
    facesWithZ.sort((a, b) => a.avgZ - b.avgZ);

    facesWithZ.forEach(face => {
      ctx.beginPath();
      ctx.moveTo(projected[face.indices[0]].x, projected[face.indices[0]].y);
      face.indices.forEach(i => ctx.lineTo(projected[i].x, projected[i].y));
      ctx.closePath();
      ctx.fillStyle = face.color;
      ctx.fill();
      ctx.strokeStyle = 'rgba(100,150,200,0.4)';
      ctx.lineWidth = 2;
      ctx.stroke();
    });

    const holeRadius = (holeDiameter / 2) * scale3D;
    const taper = beamType === 'bessel' ? 0.98 : 0.90;

    if (currentDepth > 0) {
      const cutDepthPx = currentDepth * scale3D;
      const segments = 32, depthSegs = 15;

      if (cutMode === 'hole') {
        for (let d = 0; d < depthSegs; d++) {
          const t1 = d / depthSegs, t2 = (d + 1) / depthSegs;
          if (t1 > currentDepth / cutDepth) break;
          const y1 = h/2 - t1 * cutDepthPx, y2 = h/2 - t2 * cutDepthPx;
          const r1 = beamType === 'bessel' ? holeRadius : holeRadius * (1 - t1 * (1 - taper));
          const r2 = beamType === 'bessel' ? holeRadius : holeRadius * (1 - t2 * (1 - taper));
          for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * Math.PI * 2, angle2 = ((i + 1) / segments) * Math.PI * 2;
            const pts = [
              project(Math.cos(angle1)*r1, y1, Math.sin(angle1)*r1),
              project(Math.cos(angle2)*r1, y1, Math.sin(angle2)*r1),
              project(Math.cos(angle2)*r2, y2, Math.sin(angle2)*r2),
              project(Math.cos(angle1)*r2, y2, Math.sin(angle1)*r2)
            ];
            ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
            pts.forEach(p => ctx.lineTo(p.x, p.y)); ctx.closePath();
            const darkness = 0.3 + t1 * 0.6;
            ctx.fillStyle = `rgba(10,10,15,${darkness})`; ctx.fill();
            ctx.strokeStyle = `rgba(50,50,60,${darkness*0.4})`; ctx.lineWidth = 0.5; ctx.stroke();
          }
        }
        if (isComplete) {
          const bottomPoints = [];
          for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const r = beamType === 'bessel' ? holeRadius : holeRadius * taper;
            bottomPoints.push(project(Math.cos(angle)*r, -h/2, Math.sin(angle)*r));
          }
          ctx.beginPath(); ctx.moveTo(bottomPoints[0].x, bottomPoints[0].y);
          bottomPoints.forEach(p => ctx.lineTo(p.x, p.y)); ctx.closePath();
          ctx.fillStyle = 'rgba(0,0,0,1)'; ctx.fill();
          ctx.strokeStyle = 'rgba(255,100,100,0.8)'; ctx.lineWidth = 3; ctx.stroke();
        }
      } else {
        const lineHalfLength = (lineLength / 2) * scale3D;
        const lineHalfWidth_val = (lineWidth / 2) * scale3D;
        for (let d = 0; d < depthSegs; d++) {
          const t1 = d / depthSegs, t2 = (d + 1) / depthSegs;
          if (t1 > currentDepth / cutDepth) break;
          const y1 = h/2 - t1 * cutDepthPx, y2 = h/2 - t2 * cutDepthPx;
          const corners1 = [
            project(-lineHalfLength, y1, -lineHalfWidth_val), project(lineHalfLength, y1, -lineHalfWidth_val),
            project(lineHalfLength, y1, lineHalfWidth_val), project(-lineHalfLength, y1, lineHalfWidth_val)
          ];
          const corners2 = [
            project(-lineHalfLength, y2, -lineHalfWidth_val), project(lineHalfLength, y2, -lineHalfWidth_val),
            project(lineHalfLength, y2, lineHalfWidth_val), project(-lineHalfLength, y2, lineHalfWidth_val)
          ];
          for (let i = 0; i < 4; i++) {
            const next = (i + 1) % 4;
            ctx.beginPath();
            ctx.moveTo(corners1[i].x, corners1[i].y);
            ctx.lineTo(corners1[next].x, corners1[next].y);
            ctx.lineTo(corners2[next].x, corners2[next].y);
            ctx.lineTo(corners2[i].x, corners2[i].y);
            ctx.closePath();
            const darkness = 0.3 + t1 * 0.6;
            ctx.fillStyle = `rgba(10,10,15,${darkness})`; ctx.fill();
            ctx.strokeStyle = `rgba(50,50,60,${darkness*0.3})`; ctx.lineWidth = 0.5; ctx.stroke();
          }
        }
        if (isComplete) {
          const lineHalfLength2 = (lineLength / 2) * scale3D;
          const lineHalfWidth2 = (lineWidth / 2) * scale3D;
          const bottomCorners = [
            project(-lineHalfLength2, -h/2, -lineHalfWidth2), project(lineHalfLength2, -h/2, -lineHalfWidth2),
            project(lineHalfLength2, -h/2, lineHalfWidth2), project(-lineHalfLength2, -h/2, lineHalfWidth2)
          ];
          ctx.beginPath(); ctx.moveTo(bottomCorners[0].x, bottomCorners[0].y);
          bottomCorners.forEach(p => ctx.lineTo(p.x, p.y)); ctx.closePath();
          ctx.fillStyle = 'rgba(0,0,0,1)'; ctx.fill();
          ctx.strokeStyle = 'rgba(255,100,100,0.8)'; ctx.lineWidth = 3; ctx.stroke();
        }
      }

      if (isComplete) {
        const labelPos = project(0, -h/2 - 30, 0);
        ctx.fillStyle = '#00ff00'; ctx.font = 'bold 18px Arial';
        const labelText = currentDepth >= sampleThickness ? '\u2713 CUT THROUGH' : '\u2713 CUT COMPLETE';
        ctx.fillText(labelText, labelPos.x - 70, labelPos.y);
      }
    }

    if (isRunning || currentDepth > 0) {
      const beamStartY = h/2 + 80;
      const beamEndY = h/2 - currentDepth * scale3D;
      const angle = (rotationAngle * Math.PI) / 180;
      const beamX = Math.cos(angle) * holeRadius;
      const beamZ = Math.sin(angle) * holeRadius;
      const beamStart = project(beamX, beamStartY, beamZ);
      const beamEnd = project(beamX, beamEndY, beamZ);

      if (beamType === 'bessel') {
        ctx.strokeStyle = 'rgba(255,100,150,0.8)'; ctx.lineWidth = 8; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(beamStart.x, beamStart.y); ctx.lineTo(beamEnd.x, beamEnd.y); ctx.stroke();
        for (let ring = 1; ring <= 2; ring++) {
          const ringR = ring * 6;
          for (let i = 0; i < 8; i++) {
            const rAngle = (i / 8) * Math.PI * 2;
            const rs = project(beamX + Math.cos(rAngle)*ringR, beamStartY, beamZ + Math.sin(rAngle)*ringR);
            const re = project(beamX + Math.cos(rAngle)*ringR, beamEndY, beamZ + Math.sin(rAngle)*ringR);
            ctx.strokeStyle = `rgba(255,150,200,${0.3/ring})`; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(rs.x, rs.y); ctx.lineTo(re.x, re.y); ctx.stroke();
          }
        }
      } else {
        ctx.strokeStyle = 'rgba(255,100,150,0.7)'; ctx.lineWidth = 10; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(beamStart.x, beamStart.y); ctx.lineTo(beamEnd.x, beamEnd.y); ctx.stroke();
      }

      if (showPlasma && isAboveThreshold) {
        const plasmaGrad = ctx.createRadialGradient(beamEnd.x, beamEnd.y, 5, beamEnd.x, beamEnd.y, 35);
        plasmaGrad.addColorStop(0, 'rgba(255,220,100,0.9)');
        plasmaGrad.addColorStop(0.5, 'rgba(255,150,50,0.5)');
        plasmaGrad.addColorStop(1, 'rgba(255,100,0,0)');
        ctx.fillStyle = plasmaGrad;
        ctx.beginPath(); ctx.arc(beamEnd.x, beamEnd.y, 35, 0, Math.PI * 2); ctx.fill();
      }
    }

    // Status overlay
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(10, 10, 380, 220);
    ctx.fillStyle = isComplete ? '#00ff00' : '#00aaff';
    ctx.font = 'bold 16px Arial';
    ctx.fillText(isComplete ? '\u2713 COMPLETE' : '\u2699\uFE0F PROCESSING', 20, 35);
    ctx.font = '13px Courier New'; ctx.fillStyle = '#ffffff';
    const status = [
      `Mode: ${cutMode.toUpperCase()} - ${cutMode === 'hole' ? `\u00D8${holeDiameter}mm` : `${lineLength}\u00D7${lineWidth}mm`}`,
      `Depth: ${currentDepth.toFixed(3)} / ${cutDepth} mm`,
      `Pass: ${currentPass} / ${numberOfPasses}`,
      `Time: ${processingTime.toFixed(1)} / ${estimatedTime.toFixed(1)} s`,
      `Material: ${materialRemoved.toFixed(2)} mm\u00B3`,
      `Fluence: ${fluence.toFixed(2)} J/cm\u00B2 (Th: ${ablationThreshold.toFixed(1)})`,
      `Spot: \u00D8${spotSize.toFixed(1)} \u00B5m`,
      `Depth/pulse: ${ablationDepthPerPulse.toFixed(3)} \u00B5m`,
      `${isAboveThreshold ? '\uD83D\uDFE2 Ablating' : '\uD83D\uDD34 Below threshold'}`,
      `Gas: ${assistGas.toUpperCase()} @ ${gasPressure} bar`
    ];
    status.forEach((line, i) => { ctx.fillText(line, 20, 60 + i * 18); });
  }, [currentDepth, sampleThickness, currentPass, numberOfPasses, processingTime, estimatedTime,
      materialRemoved, cameraRotX, cameraRotY, cameraZoom, rotationAngle, showPlasma, isRunning,
      holeDiameter, beamType, isComplete, fluence, ablationThreshold, isAboveThreshold, spotSize,
      ablationDepthPerPulse, energyPerPulse, assistGas, gasPressure, sampleWidth, sampleLength, cutDepth, cutMode, lineLength, lineWidth]);

  return (
    <div className="app-wrap">
      <div className="max-container">
        <div className="text-center mb-4">
          <h1>Industrial Laser Cut System for Glasses &amp; Transparent Materials</h1>
        </div>

        <div className="grid-main">
          {/* 3D Canvas */}
          <div className="panel panel-canvas">
            <div className="flex-between mb-3">
              <h3 style={{fontSize:'18px',fontWeight:700,color:'#fff'}}>3D Visualization</h3>
              <div className="flex-gap-2">
                <button onClick={() => setAutoRotate(!autoRotate)} className={`btn ${autoRotate ? 'btn-purple' : 'btn-gray'}`}>Auto-Rotate</button>
                <button onClick={() => setIsRunning(!isRunning)} disabled={currentDepth >= sampleThickness} className="btn btn-green" style={{fontWeight:700}}>
                  {isRunning ? <PauseIcon /> : <PlayIcon />}
                  {isRunning ? 'PAUSE' : 'START'}
                </button>
                <button onClick={reset} className="btn btn-red" style={{fontWeight:700}}>
                  <RotateIcon /> RESET
                </button>
              </div>
            </div>

            <canvas ref={canvasRef} width={1100} height={700}
              onMouseDown={handleMouseDown} onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
              onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}
            />

            <div className="mt-3" style={{background:'#1f2937',padding:'12px',borderRadius:'8px'}}>
              <div className="flex-between text-xs" style={{color:'#d1d5db',marginBottom:'8px'}}>
                <span>Cutting Progress ({cutMode === 'hole' ? 'Hole' : 'Line'} - {cutDepth}mm depth)</span>
                <span style={{fontWeight:700}}>{((currentDepth / cutDepth) * 100).toFixed(1)}%</span>
              </div>
              <div className="progress-bar-outer">
                <div className={`progress-bar-inner ${isComplete ? 'progress-green' : 'progress-blue'}`}
                     style={{ width: `${Math.max(Math.min((currentDepth / cutDepth) * 100, 100), 5)}%` }}>
                  {isComplete ? '\u2713 COMPLETE' : `${currentDepth.toFixed(2)}mm`}
                </div>
              </div>
            </div>
          </div>

          {/* Controls */}
          <div className="controls-col">
            {/* Material */}
            <div className="panel border-yellow">
              <h3 className="panel-title" style={{color:'#facc15'}}><SettingsIcon color="#facc15" /> Material Selection</h3>
              <select value={selectedMaterial} onChange={(e) => { setSelectedMaterial(e.target.value); reset(); }} disabled={isRunning} style={{borderColor:'#eab308'}}>
                <option value="fused_silica">Fused Silica (SiO₂) - High purity optics</option>
                <option value="sapphire">Sapphire (Al₂O₃) - Extreme hardness</option>
                <option value="bk7">Borosilicate (BK7) - Standard optical glass</option>
                <option value="soda_lime">Soda-Lime Glass - Window glass</option>
                <option value="silicon">Silicon (Si) - Semiconductor wafer</option>
                <option value="pmma">PMMA (Acrylic) - Transparent plastic</option>
              </select>
              <div className="mt-2 text-xs italic text-gray-400">Threshold @ {wavelength}nm: {getAblationThreshold().toFixed(2)} J/cm²</div>
            </div>

            {/* Sample Dimensions */}
            <div className="panel">
              <h3 className="panel-title"><SettingsIcon color="#4ade80" /> Sample Dimensions</h3>
              <div className="grid-3">
                <div>
                  <label>Width (mm)</label>
                  <select value={sampleWidth} onChange={(e) => setSampleWidth(Number(e.target.value))} disabled={isRunning}>
                    {[25,50,75,100,150].map(v => <option key={v} value={v}>{v}</option>)}
                  </select>
                </div>
                <div>
                  <label>Length (mm)</label>
                  <select value={sampleLength} onChange={(e) => setSampleLength(Number(e.target.value))} disabled={isRunning}>
                    {[25,50,75,100,150].map(v => <option key={v} value={v}>{v}</option>)}
                  </select>
                </div>
                <div>
                  <label className="label-bold label-yellow">Thickness (mm)</label>
                  <select value={sampleThickness} onChange={(e) => setSampleThickness(Number(e.target.value))} disabled={isRunning} style={{borderColor:'#eab308'}}>
                    {[0.5,1,2,3,5,10,15,20].map(v => <option key={v} value={v}>{v}</option>)}
                  </select>
                </div>
              </div>
            </div>

            {/* Laser System */}
            <div className="panel">
              <h3 className="panel-title">Laser System</h3>
              <div className="space-y-2">
                <div>
                  <label>Laser Type</label>
                  <select value={laserType} onChange={(e) => { setLaserType(e.target.value); setLaserModel(Object.keys(laserSystems[e.target.value])[0]); }}>
                    <option value="femtosecond">Femtosecond (fs)</option>
                    <option value="picosecond">Picosecond (ps)</option>
                    <option value="nanosecond">Nanosecond (ns)</option>
                  </select>
                </div>
                <div>
                  <label>Commercial Model</label>
                  <select value={laserModel} onChange={(e) => setLaserModel(e.target.value)}>
                    {Object.keys(laserSystems[laserType]).map(model => <option key={model} value={model}>{model}</option>)}
                  </select>
                </div>
                <div>
                  <label>Wavelength (nm)</label>
                  <select value={wavelength} onChange={(e) => setWavelength(Number(e.target.value))}>
                    {getCurrentModelSpecs().wavelengths.map(wl => <option key={wl} value={wl}>{wl} nm</option>)}
                  </select>
                </div>
                <div>
                  <label>Pulse Width: {laserType === 'femtosecond' ? `${pulseWidth} fs` : laserType === 'picosecond' ? `${(pulseWidth/1000).toFixed(1)} ps` : `${(pulseWidth/1000).toFixed(0)} ns`}</label>
                  <input type="range" min={getCurrentModelSpecs().pulseWidth[0]} max={getCurrentModelSpecs().pulseWidth[1]}
                    step={laserType === 'femtosecond' ? 50 : laserType === 'picosecond' ? 1000 : 10000}
                    value={pulseWidth} onChange={(e) => setPulseWidth(Number(e.target.value))} />
                </div>
                <div>
                  <label>Average Power: {averagePower} W</label>
                  <input type="range" min={0} max={getCurrentModelSpecs().power[1]} step={1} value={averagePower} onChange={(e) => setAveragePower(Number(e.target.value))} />
                </div>
                <div>
                  <label>Rep Rate: {repetitionRate} kHz</label>
                  <input type="range" min={getCurrentModelSpecs().repRate[0]} max={getCurrentModelSpecs().repRate[1]} step={10} value={repetitionRate} onChange={(e) => setRepetitionRate(Number(e.target.value))} />
                </div>
                {laserType === 'femtosecond' && (
                  <div style={{display:'flex',alignItems:'center',gap:'8px',paddingTop:'4px'}}>
                    <input type="checkbox" checked={burstMode} onChange={(e) => setBurstMode(e.target.checked)} />
                    <label style={{margin:0,color:'#fff'}}>Burst Mode ({pulsesPerBurst} pulses @ {burstFrequency} MHz)</label>
                  </div>
                )}
              </div>
            </div>

            {/* Beam Delivery */}
            <div className="panel">
              <h3 className="panel-title">Beam Delivery Optics</h3>
              <div className="space-y-2">
                <div>
                  <label>Beam Type</label>
                  <select value={beamType} onChange={(e) => setBeamType(e.target.value)}>
                    <option value="bessel">Bessel Beam (Cylindrical)</option>
                    <option value="gaussian">Gaussian (Standard)</option>
                    <option value="flattop">Flat-Top</option>
                    <option value="airy">Airy Beam</option>
                  </select>
                </div>
                <div>
                  <label>f-Theta Lens (mm)</label>
                  <select value={focalLength} onChange={(e) => setFocalLength(Number(e.target.value))}>
                    <option value={50}>50 (Small FOV, tight spot)</option>
                    <option value={100}>100 (Standard)</option>
                    <option value={160}>160 (Medium FOV)</option>
                    <option value={254}>254 (Large FOV)</option>
                    <option value={330}>330 (XL FOV)</option>
                  </select>
                </div>
                <div>
                  <label>Numerical Aperture: {numericalAperture.toFixed(2)}</label>
                  <input type="range" min={0.05} max={0.50} step={0.05} value={numericalAperture} onChange={(e) => setNumericalAperture(Number(e.target.value))} />
                </div>
                <div>
                  <label>Beam Diameter: {beamDiameter} mm (at lens input)</label>
                  <input type="range" min={4} max={14} step={1} value={beamDiameter} onChange={(e) => setBeamDiameter(Number(e.target.value))} />
                </div>
                <div className="info-box">
                  <div className="title">Calculated:</div>
                  <div className="val">Spot size: &Oslash;{spotSize.toFixed(1)} &micro;m</div>
                  <div className="val">Rayleigh range: {rayleighRange.toFixed(0)} &micro;m</div>
                  {laserType === 'femtosecond' && <div className="val">Peak power: {peakPower.toFixed(1)} MW</div>}
                </div>
              </div>
            </div>

            {/* Motion Control */}
            <div className="panel">
              <h3 className="panel-title">Motion Control &amp; Cut Parameters</h3>
              <div className="space-y-2">
                <div>
                  <label className="label-bold label-cyan">Cut Mode</label>
                  <select value={cutMode} onChange={(e) => { setCutMode(e.target.value); reset(); }} disabled={isRunning} style={{borderColor:'#22d3ee'}}>
                    <option value="hole">Hole Drilling (Circular)</option>
                    <option value="line">Line Cutting (Linear groove)</option>
                  </select>
                </div>
                <div className="yellow-box">
                  <label>Target Cut Depth: {cutDepth} mm</label>
                  <input type="number" min={0.1} max={sampleThickness} step={0.1} value={cutDepth}
                    onChange={(e) => setCutDepth(Number(e.target.value))} disabled={isRunning}
                    className="border-yellow-input" />
                  <div className="hint">Sample thickness: {sampleThickness}mm{cutDepth >= sampleThickness && ' (Cut-through!)'}</div>
                </div>
                {cutMode === 'hole' ? (
                  <>
                    <div>
                      <label>Drilling Strategy</label>
                      <select value={drillingStrategy} onChange={(e) => setDrillingStrategy(e.target.value)}>
                        <option value="helical">Helical (spiral, best for large &Oslash;)</option>
                        <option value="trepanning">Trepanning (circular path)</option>
                        <option value="percussion">Percussion (static, small &Oslash;)</option>
                      </select>
                    </div>
                    <div>
                      <label>Hole Diameter: {holeDiameter} mm</label>
                      <input type="range" min={0.5} max={25} step={0.5} value={holeDiameter} onChange={(e) => setHoleDiameter(Number(e.target.value))} disabled={isRunning} />
                    </div>
                  </>
                ) : (
                  <>
                    <div>
                      <label>Line Length: {lineLength} mm</label>
                      <input type="range" min={1} max={50} step={0.5} value={lineLength} onChange={(e) => setLineLength(Number(e.target.value))} disabled={isRunning} />
                    </div>
                    <div>
                      <label>Line Width: {lineWidth} mm</label>
                      <input type="range" min={0.1} max={5} step={0.1} value={lineWidth} onChange={(e) => setLineWidth(Number(e.target.value))} disabled={isRunning} />
                    </div>
                  </>
                )}
                <div>
                  <label>Scanning System</label>
                  <select value={scanningSystem} onChange={(e) => setScanningSystem(e.target.value)}>
                    <option value="galvo">Galvo Scanner (fast, &lt;500mm)</option>
                    <option value="stage">Linear Stage (slow, precise)</option>
                    <option value="hybrid">Hybrid (galvo + stage)</option>
                  </select>
                </div>
                <div>
                  <label>Passes (for {cutDepth}mm): {numberOfPasses}</label>
                  <input type="range" min={10} max={1000} step={10} value={numberOfPasses} onChange={(e) => setNumberOfPasses(Number(e.target.value))} disabled={isRunning} />
                </div>
                <div>
                  <label>Pulse Overlap: {pulseOverlap}%</label>
                  <input type="range" min={50} max={95} step={5} value={pulseOverlap} onChange={(e) => setPulseOverlap(Number(e.target.value))} />
                </div>
                <div>
                  <label>Scan Speed: {scanSpeed} mm/s</label>
                  <select value={scanSpeed} onChange={(e) => setScanSpeed(Number(e.target.value))}>
                    <option value={100}>100 (precise)</option>
                    <option value={500}>500 (balanced)</option>
                    <option value={1000}>1000 (fast)</option>
                    <option value={2000}>2000 (high throughput)</option>
                    <option value={5000}>5000 (max galvo speed)</option>
                  </select>
                </div>
              </div>
            </div>

            {/* Assist Gas */}
            <div className="panel">
              <h3 className="panel-title">Assist Gas System</h3>
              <div className="space-y-2">
                <div>
                  <label>Gas Type</label>
                  <select value={assistGas} onChange={(e) => setAssistGas(e.target.value)}>
                    <option value="none">None (vacuum/air)</option>
                    <option value="air">Compressed Air (cheap)</option>
                    <option value="nitrogen">Nitrogen (clean, inert)</option>
                    <option value="argon">Argon (premium, inert)</option>
                    <option value="oxygen">Oxygen (oxidative)</option>
                  </select>
                </div>
                <div>
                  <label>Pressure: {gasPressure} bar</label>
                  <input type="range" min={0.5} max={10} step={0.5} value={gasPressure} onChange={(e) => setGasPressure(Number(e.target.value))} />
                </div>
                <div>
                  <label>Flow Rate: {gasFlowRate} L/min</label>
                  <input type="range" min={5} max={50} step={5} value={gasFlowRate} onChange={(e) => setGasFlowRate(Number(e.target.value))} />
                </div>
              </div>
            </div>

            {/* Material Properties */}
            <div className="material-panel">
              <h3>{currentMaterial.name}</h3>
              <div className="material-props">
                <div>Density: {currentMaterial.density} g/cm³</div>
                <div>n @ {wavelength}nm: {wavelength === 1030 ? currentMaterial.refractiveIndex1030nm : currentMaterial.refractiveIndex515nm}</div>
                <div>Transmission: {(wavelength === 1030 ? currentMaterial.transmissionAt1030nm * 100 : wavelength === 515 ? currentMaterial.transmissionAt515nm * 100 : currentMaterial.transmissionAt355nm * 100).toFixed(0)}%</div>
                <div>Melting: {currentMaterial.meltingPoint}°C</div>
                <div>Hardness: {currentMaterial.hardness} Mohs</div>
                <div>E-modulus: {currentMaterial.youngsModulus} GPa</div>
              </div>
              <div className="material-desc">{currentMaterial.description}</div>
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="footer-grid">
          <div className="footer-card">
            <h4 className="c-orange">{'\uD83C\uDFAF'} Bessel Beam</h4>
            <p>Non-diffracting central core maintains constant diameter {spotSize.toFixed(1)}&micro;m over {(rayleighRange * 10 / 1000).toFixed(1)}mm depth. Perfect for deep cylindrical holes with &lt;2% taper.</p>
          </div>
          <div className="footer-card">
            <h4 className="c-green">{'\u26A1'} Femtosecond Advantage</h4>
            <p>Ultra-short pulses ({pulseWidth}fs) create "cold ablation" with minimal HAZ (&lt;1&micro;m). Peak power: {peakPower.toFixed(1)}MW enables multi-photon absorption in transparent materials.</p>
          </div>
          <div className="footer-card">
            <h4 className="c-blue">{'\uD83D\uDD04'} Variable Depth Cutting</h4>
            <p>{cutMode === 'hole' ? 'Helical drilling' : 'Line cutting'} with {numberOfPasses} passes removes {depthPerPass.toFixed(1)}&micro;m per pass. Target depth: {cutDepth}mm{cutDepth >= sampleThickness ? ' (full cut-through)' : ' (partial cut)'}. Total time: {estimatedTime.toFixed(1)}s.</p>
          </div>
          <div className="footer-card">
            <h4 className="c-purple">{'\uD83D\uDCCA'} Process Quality</h4>
            <p>Fluence {fluence.toFixed(1)} J/cm² {isAboveThreshold ? '>' : '<'} threshold {ablationThreshold.toFixed(1)} J/cm². Ablation rate: {ablationDepthPerPulse.toFixed(3)}&micro;m/pulse. Assist gas prevents debris redeposition.</p>
          </div>
        </div>
      </div>
    </div>
  );
}

ReactDOM.render(<IndustrialLaserCutthrough />, document.getElementById('root'));
</script>
</body>
</html>
